<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VIB3RAC3RS — GRANDPRIS</title>
  <style>
    html, body { height:100%; margin:0; background:#0b0e12; }
    body { display:grid; place-items:center; overflow:hidden; }
    canvas { width: min(100vw, 700px); height: 100vh; image-rendering: pixelated; background:#0b0e12; display:block; }
    .hud { position:fixed; top:8px; left:8px; color:#e6edf3; font:600 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .hint { position:fixed; right:12px; bottom:12px; color:#e6edf3; opacity:.8; font:500 12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  </style>
</head>
<body>
  <div class="hud">Score: <span id="score">0</span></div>
  <div class="hint">A/◀ left · D/▶ right · Space to (re)start</div>
  <canvas id="game" width="350" height="700"></canvas>

  <script>
    // ---- Config ----
    const LANES = 3;
    const LANE_W = 90;           // logical width per lane
    const ROAD_W = LANE_W * LANES;
    const H = 700;               // canvas height (logical)
    const MARGIN = 20;           // margin around road
    const CAR_W = 52, CAR_H = 32; // render size

    // ---- Setup canvas ----
    const cvs = document.getElementById('game');
    const ctx = cvs.getContext('2d');

    // Center road horizontally
    const roadX = (cvs.width - ROAD_W) / 2;

    // ---- Load chosen car (optional image) ----
    const selectedCar = Number(localStorage.getItem('selectedCar')) || 1; // 1..3
    const carImg = new Image();
    const carSrcMap = {
      1: 'assets/1.RED.png',
      2: 'assets/2.YELLOW.png',
      3: 'assets/3.WHITE.png'
    };
    carImg.src = carSrcMap[selectedCar] || carSrcMap[1];

    // ---- Game state ----
    let state = 'ready'; // 'ready' | 'running' | 'gameover'
    let lane = 1;        // 0..LANES-1
    let y = H - 100;     // car y
    let obstacles = [];  // {lane, y, speed}
    let t = 0;           // time
    let score = 0;

    function reset() {
      state = 'running';
      lane = 1;
      obstacles = [];
      t = 0;
      score = 0;
      document.getElementById('score').textContent = '0';
    }

    // ---- Input ----
    window.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (e.code === 'KeyA' || e.code === 'ArrowLeft') { lane = Math.max(0, lane - 1); }
      else if (e.code === 'KeyD' || e.code === 'ArrowRight') { lane = Math.min(LANES-1, lane + 1); }
      else if (e.code === 'Space') { if (state !== 'running') reset(); }
    });
    window.addEventListener('click', () => { if (state !== 'running') reset(); });

    // ---- Helpers ----
    function laneX(i) { return roadX + i*LANE_W + (LANE_W - CAR_W)/2; }

    function spawnObstacle() {
      const lane = Math.floor(Math.random()*LANES);
      const speed = 2.2 + Math.random()*1.8; // pixels per frame
      obstacles.push({ lane, y: -CAR_H - 10, speed });
    }

    // ---- Render ----
    function drawRoad(scroll) {
      // asphalt
      ctx.fillStyle = '#111722';
      ctx.fillRect(roadX, 0, ROAD_W, H);
      // borders
      ctx.fillStyle = '#3b465a';
      ctx.fillRect(roadX - 6, 0, 6, H);
      ctx.fillRect(roadX + ROAD_W, 0, 6, H);
      // dashed lane markers (scrolling)
      ctx.fillStyle = '#9aa7bd';
      for (let l=1; l<LANES; l++) {
        const x = roadX + l*LANE_W - 2;
        for (let y= (scroll % 40) - 40; y < H; y += 40) {
          ctx.fillRect(x, y, 4, 20);
        }
      }
    }

    function drawCar(x, y) {
      if (carImg.complete && carImg.naturalWidth) {
        ctx.drawImage(carImg, x, y, CAR_W, CAR_H);
      } else {
        // fallback rectangle car
        ctx.fillStyle = ['#e74c3c','#f1c40f','#ecf0f1'][selectedCar-1] || '#e74c3c';
        ctx.fillRect(x, y, CAR_W, CAR_H);
      }
    }

    function drawObstacle(o) {
      ctx.fillStyle = '#c0d0e0';
      ctx.fillRect(laneX(o.lane), o.y, CAR_W, CAR_H);
    }

    function aabb(ax,ay,aw,ah, bx,by,bw,bh){ return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by; }

    // ---- Loop ----
    function frame() {
      requestAnimationFrame(frame);
      ctx.clearRect(0,0,cvs.width,cvs.height);

      if (state === 'ready') {
        drawRoad(0);
        drawCar(laneX(lane), y);
        // Title
        ctx.fillStyle = '#e6edf3';
        ctx.font = 'bold 16px monospace';
        ctx.fillText('Press Space to start', 14, 30);
        return;
      }

      if (state === 'running') {
        t += 1;
        const scroll = t * 3;
        drawRoad(scroll);

        // Spawn
        if (t % 50 === 0) spawnObstacle();

        // Update obstacles
        for (const o of obstacles) o.y += o.speed * 2.2;
        // Cull
        obstacles = obstacles.filter(o => o.y < H + 60);

        // Draw obstacles
        for (const o of obstacles) drawObstacle(o);

        // Draw player
        const px = laneX(lane);
        drawCar(px, y);

        // Collision
        for (const o of obstacles) {
          if (aabb(px,y,CAR_W,CAR_H, laneX(o.lane),o.y,CAR_W,CAR_H)) {
            state = 'gameover';
          }
        }

        // Score
        score += 1; // simple time-based score
        if ((score & 7) === 0) document.getElementById('score').textContent = String(score);
        return;
      }

      if (state === 'gameover') {
        drawRoad(t*3);
        for (const o of obstacles) drawObstacle(o);
        drawCar(laneX(lane), y);
        ctx.fillStyle = '#ffd400';
        ctx.font = 'bold 18px monospace';
        ctx.fillText('Crashed! Space to retry', 14, 40);
        return;
      }
    }

    // Start in ready
    state = 'ready';
    frame();
  </script>
</body>
</html>
